# PowerShell コーディングスタンダード

## コーディング哲学: 堅牢性と生産性の両立を目指して

我々は、単に動作するコードを書くだけでなく、将来にわたって理解しやすく、変更に強く、信頼性の高いソフトウェアを効率的に構築ことを目指します。そのために、以下の5つの基本原則を開発の指針とします。

### 1. 「意図」の明示化と共有 (Clarity of Intent)

- **なぜ？**: コードはコミュニケーションの手段です。書いた瞬間の自分だけでなく、数ヶ月後の自分、他の開発者、そしてAI支援ツールにとっても、そのコードが「何を」「なぜ」「どのように」行おうとしているのかが明確に伝わらなければ、誤解やバグ、非効率なメンテナンスの原因となります。
- **どうする？**:
  - **命名**: 変数、関数、パラメータには、その役割と目的を正確に反映した、曖昧さのない名前を付けます。
  - **コメント**: コードだけでは伝わらない設計判断の背景、前提条件、潜在的なリスク、将来の改善点などをコメントで補足します。
  - **型宣言**: データがどのような構造や種類であるべきかを型で明示し、データの使われ方に関する意図を伝えます。
  - **ドキュメント**: 設計書や仕様書は、コードの「意図」を記録し、関係者間で共有するための公式な手段と位置づけ、コードとの同期を保ちます。

### 2. 「検証」の習慣化と自動化 (Culture of Verification)

- **なぜ？**: 人間の注意力には限界があり、すべてのバグを手動で見つけることは不可能です。検証を開発プロセスに組み込み、可能な限り自動化することで、品質を継続的に担保し、変更に対する信頼性を高めます。
- **どうする？**:
  - **マイクロテスト**: 新しいコード片や小さなロジックは、作成後すぐにその場で動作確認を行います。
  - **ユニットテスト**: 関数やモジュール単位で、期待される入力に対する期待される出力を定義し、自動検証する仕組みを（将来的にPester等が安定利用可能になった際には）導入します。
  - **結合テスト**: 複数のコンポーネントが連携して正しく動作するかを検証します。
  - **手動テストの体系化**: 自動化が難しい部分については、明確な手順と期待結果を伴う体系的な手動テストケースを作成し、変更時には必ず実施します。
  - **「期待動作」の事前定義**: テストを設計することは、そのコードが満たすべき仕様を明確にする行為そのものです。

### 3. 「影響範囲」の意識と管理 (Consciousness of Impact)

- **なぜ？**: ソフトウェアの各部分は相互に影響し合っています。一部分の変更が予期せぬ広範囲な問題を引き起こすことを避けるためには、変更の影響範囲を常に意識し、それを局所化する設計が不可欠です。
- **どうする？**:
  - **モジュール化・疎結合**: 機能を論理的な単位でモジュールや関数に分割し、明確なインターフェースを通じてのみ連携させます。これにより、変更の影響が内部に留まりやすくなります。
  - **パラメータ設計**: 関数のパラメータは、必要十分な情報を、明確な名前と型で受け取るようにします。グローバル変数への安易な依存は避けます。
  - **変更時の影響分析**: コードを修正する際には、その変更が他にどのような影響を及ぼす可能性があるかを事前に検討します。
  - **バージョン管理**: Git等を利用して変更履歴を管理し、問題発生時の原因特定やロールバックを容易にします。

### 4. 「単純さ」の追求 (Simplicity First)

- **なぜ？**: 複雑さは理解を妨げ、バグを生み出し、メンテナンスコストを増大させます。多くの場合、最も単純な解決策が最も堅牢で優れた解決策です。
- **どうする？**:
  - **YAGNI (You Ain't Gonna Need It)**: 現時点で明確に必要とされていない機能や、過度な一般化は実装しません。
  - **KISS (Keep It Simple, Stupid)**: 可能な限り簡潔で、直接的で、理解しやすいコードを目指します。
  - **リファクタリング**: コードが読みにくくなったり、複雑になりすぎたりした場合は、振る舞いを変えずに内部構造を改善するリファクタリングを適宜行います。

### 5. 「学習と改善」の継続 (Continuous Learning and Improvement)

- **なぜ？**: 技術は進化し、我々の理解も深まります。過去の失敗や成功から学び、それを次の行動に活かすことで、個人としてもプロジェクトとしても成長し続けることができます。
- **どうする？**:
  - **根本原因分析**: 問題が発生した際には、その場しのぎの修正だけでなく、「なぜその問題が起きたのか」という根本原因まで掘り下げて考えます。
  - **再発防止策の具体化**: 特定された根本原因に対して、具体的な対策（規約の改訂、チェックリストの導入、新しいツールの検討など）を講じ、それを実践します。
  - **知識・技術のアップデート**: PowerShellの新機能、より効果的なデバッグ手法、設計パターンなど、常に新しい知識を学び、スキルを向上させます。
  - **AIとの協調の最適化**: AI支援ツールを効果的に活用し、生産性を高めるための対話方法や検証プロセスを洗練させていきます。

これらの哲学は、以下に示す具体的なコーディング規約の基盤となります。規約の各項目は、これらの哲学のいずれか、あるいは複数を実現するための具体的な手段です。

## 序文

このドキュメントは、MD-WBS GeneratorプロジェクトにおけるPowerShellスクリプト開発のための一貫性と品質を確保するためのコーディング規約とベストプラクティスを定義します。この規約に従うことで、コードの可読性、保守性、堅牢性を向上させることを目的とします。

## 1. 全般的な原則

### 1.1. スクリプトの目的と責任範囲の明確化

- 各スクリプト（`.ps1`）およびモジュール（`.psm1`）は、そのファイルが持つ主要な目的と責任範囲を明確に持つべきである。
- スクリプト冒頭のコメントブロック（Synopsis、Description）にこれを記述する。
  - 内容: 各スクリプトおよびモジュールは、その主要な目的をコメントヘッダに明記する。

### 1.2. 可読性の重視

- **命名規則**: 変数名、関数名、パラメータ名は意味が分かりやすく、一貫性のある命名規則に従う（詳細は各セクション参照）。
- **インデント**: プロジェクトで統一されたインデントスタイル（例: スペース4つ）を使用する。
- **コメント**: 複雑なロジックや意図が不明瞭な箇所には適切なコメントを記述する。
  - 内容: 一貫した命名規則、インデント（スペース4つ）、適切なコメントを心がける。

### 1.3. 保守性の重視

- **モジュール化**: 再利用可能な関数群はモジュールとして分離する。
- **変更容易性**: 特定の値をハードコーディングせず、設定値はパラメータや設定ファイルで管理する。
- **DRY原則（Don't Repeat Yourself）**: 同じコードの繰り返しを避け、関数やループで共通化する。
  - 内容: DRY原則に従い、再利用可能なコードは関数やモジュールに分離する。ハードコーディングを避ける。

### 1.4. 堅牢性の重視

- **エラーハンドリング**: 主要な処理は `try-catch-finally` で保護し、予期せぬエラーに対応する。
- **入力検証**: 関数やスクリプト外部からの入力は、処理前に妥当性を検証する。
  - 内容: 予期せぬエラーに対応するため、主要処理はエラーハンドリングを適切に行う。入力値の検証を行う。

### 1.5. `Set-StrictMode -Version Latest` の使用

- **規則**: すべての `.ps1` および `.psm1` ファイルの先頭（`#Requires` の直後、`param` ブロックの前など）に `Set-StrictMode -Version Latest` を記述する。
- **理由**: 未定義変数へのアクセス、存在しないプロパティへのアクセス、関数呼び出し時の括弧の省略などをエラーとして扱い、潜在的なバグを早期に発見するため。
  - 内容: 全てのスクリプトファイルの先頭に記述し、未定義変数等の潜在的エラーを早期に検出する。

### 1.6. `$ErrorActionPreference = "Stop"` の基本設定

- **規則**: スクリプトのグローバルスコープ（または主要な処理ブロックの先頭）で `$ErrorActionPreference = "Stop"` を設定する。
- **理由**: コマンドレットが出すエラー（ノンターミネーティングエラー）をターミネーティングエラーに変換し、`try-catch` で確実に捕捉できるようにするため。関数単位で異なるエラーアクションが必要な場合は、関数内でローカルに設定を変更し `finally` で戻すか、コマンドレットごとに `-ErrorAction` パラメータで指定する。
  - 内容: スクリプトの主要部分ではエラー発生時に処理を停止させる。これにより `try-catch` での確実なエラー捕捉を可能にする。

## 2. 変数とデータ型

### 2.1. 変数名の命名規則

- **ローカル変数、`パラメータ`: `$camelCase`（例: `$inputFilePath`、`$retryCount`）
- **スクリプトスコープ変数**: `$script:PascalCase`（例: `$script:LogFilePath`）
- **グローバルスコープ変数**: 原則として使用を避ける。必要な場合は `$global:PascalCase` とし、使用理由をコメントで明記。
- **意味のある名前**: 変数の内容や目的を表す、具体的で理解しやすい名前を付ける。短い略語よりも明確な単語を優先。
- **Boolean型変数**: `$isReady`、`$hasError` のように、状態が明確にわかる接頭辞を推奨。
  - 内容: ローカル変数は `$camelCase`、スクリプトスコープ変数は `$script:PascalCase`。意味が明確な名前を使用する。

### 2.2. 変数のスコープの適切な使用

- **原則**: ローカルスコープを基本とし、不必要に広いスコープ（`$script:`、`$global:`）の変数は使用しない。
- **スクリプトスコープ**: モジュール内の関数間で状態を共有する場合など、限定的な状況でのみ使用を検討。
- **グローバルスコープ**: 極力避ける。もし使用する場合は、その影響範囲と必要性を十分に検討し、コメントで明記する。
  - 内容: グローバルスコープの使用は極力避け、スクリプトスコープも必要最小限に。原則ローカルスコープ。

### 2.3. 変数の明示的な初期化

- **規則**: 変数は、最初に使用する前（とくに値が代入される前）に、適切な型のデフォルト値で初期化することを推奨する（例: `$myString = ""`、`$myArray = @（）`、`$myInt = 0`、`$myObject = $null`）。
- **理由**: 未初期化変数による意図しない動作やエラーを防ぐ。
  - 内容: 変数は使用前に `$null` や適切な型のデフォルト値で初期化することを強く推奨する。

### 2.4. パラメータと変数への厳密な型指定の推奨

- **規則**: 関数のパラメータ、関数の戻り値（可能な場合）、および主要な変数には、可能な限り厳密な型を指定する。
- **型**: `[string]`、`[int]`、`[double]`、`[bool]`、`[datetime]`、`[array]`、`[hashtable]`、`[System.Collections.Generic.List[<Type>]]`、カスタムクラス型など。
- **`[object]`型**: 汎用的に値を受け付ける必要がある場合に限定的に使用。
- **理由**: 型安全性の向上、意図しない型変換によるバグの防止、コードの可読性向上。
  - 内容: 関数パラメータ、戻り値、主要変数には可能な限り厳密な型 (`[string]`, `[int]`, `[datetime]`, `[object[]]`, カスタムクラス等) を指定する。
  - **特に注意**: 今回のデバッグで、パラメータの型不一致（例: `[string]` を期待する場所に `[int]` が渡る）が原因で対話的入力が求められる問題が多発したため、型指定とその検証は入念に行う。

### 2.5. マジックナンバー・ハードコーディングの禁止

- **規則**: スクリプト内に直接記述された具体的な数値（マジックナンバー）や文字列リテラル（ハードコーディングされたパス、URL、固定パラメータなど）は避ける。
  - **2.5.1. 設定値の管理**: スクリプト冒頭の定数セクション（読み取り専用変数 `Set-Variable -Name MyConstant -Value "value" -Option Constant` や、`$Configuration` ハッシュテーブルなど）、または外部設定ファイル（JSON、XML、INIなど）で一元管理する。
  - **2.5.2. パラメータデフォルト値**: スクリプトパラメータのデフォルト値として定義する。
- **理由**: 設定変更の容易化、可読性の向上、 typoの防止。
- **例外**: 非常に自明な固定値（例: ループの初期値 `0` や `1`、配列の最初のインデックス `0` など）は許容。
  - 内容: スクリプト内に直接値を記述せず、設定ファイル、スクリプト冒頭の定数変数、またはパラメータのデフォルト値として定義する。
  - **特に注意**: ファイルパス、固定的な数値（Excelの開始行など）はハードコードしない。

## 3. 関数とモジュール

### 3.1. 関数名の命名規則

- **標準動詞-名詞形式**: PowerShellの標準コマンドレットに倣い、「動詞～名詞」の形式（PascalCase）を使用する（例: `Get-Data`、`Set-ItemProperty`、`Invoke-WebRequest`）。
- **承認された動詞**: `Get-Verb` で表示される標準動詞を優先的に使用する。
- **接頭辞**: プロジェクト固有の関数群には、共通の接頭辞（例: `MDWBS-GetTaskDetail`）を付けることを検討（モジュール化する場合はモジュール名が接頭辞の役割を果たす）。
  - 内容: `Get-Verb` で承認された動詞と明確な名詞を組み合わせた `Verb-Noun` 形式（PascalCase）とする。

### 3.2. 関数のパラメータ定義

- **3.2.1. `[CmdletBinding()]` 属性**: 高度な機能（`-Verbose`、`-Debug` のサポート、パイプライン入力など）を可能にするため、原則としてすべての推奨関数に付与する。
- **3.2.2. 型指定と必須属性**: 各パラメータには厳密な型を指定し、必須パラメータには `[Parameter(Mandatory=$true)]` を明記する。
- **3.2.3. デフォルト値**: オプションパラメータには、意味のあるデフォルト値を設定する。
- **3.2.4. パラメータセット**: 複数のパラメータの組み合わせがあり、相互に排他的な場合はパラメータセット（`ParameterSetName` 属性）の使用を検討する。
- **3.2.5. 位置指定パラメータ**: 乱用を避け、主要な1～2パラメータに限定する（`[Parameter(Position=0)]`）。それ以外は名前付きパラメータを推奨。
  - 内容: `[CmdletBinding()]` を付与。各パラメータには型指定、`[Parameter(Mandatory=$true)]` または `$false` (デフォルト値と共に) を明記する。
  - **特に注意**: **関数定義側のパラメータ名・型・必須属性と、呼び出し側のパラメータ名・型・渡す値が完全に一致していることを徹底的に確認する。** 今回のデバッグの大部分はここの不整合が原因であった。

### 3.3. 単一責任の原則（SRP）

- **規則**: 各関数は、ひとつの明確に定義されたタスクのみを実行するように設計する。関数が長大になったり、複数の異なる処理を内包したりする場合は、より小さな関数に分割することを検討する。
- **理由**: テスト容易性、再利用性、可読性、保守性の向上。
  - 内容: 一つの関数は一つの明確な責務のみを持つ。

### 3.4. 共通関数のモジュール化

- **3.4.1. モジュールファイル（`.psm1`）**: 複数のスクリプトで再利用可能な関数や、論理的にまとまった機能群は、`.psm1` ファイルとしてモジュール化する。
- **3.4.2. エクスポート**: モジュール外部から使用される関数のみを `Export-ModuleMember -Function <FunctionName>` で明示的にエクスポートする。内部ヘルパー関数はエクスポートしない。
- **3.4.3. モジュールマニフェスト（`.psd1`）**: モジュールには必ず対応するマニフェストファイルを作成する。
  - **必須項目**: `ModuleVersion`、`GUID`（一意の値）、`Author`、`Description`、`RootModule`（psm1ファイル名）、`FunctionsToExport`（エクスポートする関数名の配列）など。
  - **`Copyright`**: 静的な文字列で記述する（コマンド展開は不可）。
    - 内容: 複数のスクリプトで利用する汎用関数は `.psm1` モジュールに分離し、`.psd1` マニフェストファイルで適切に定義（`GUID`, `RootModule`, `FunctionsToExport` 等）する。
    - **特に注意**: マニフェストファイル内ではコマンド展開 (`$(Get-Date)`) を使用しない。静的な値を記述する。

### 3.5. モジュールロード時の副作用の排除

- **3.4.4. モジュールロード時の副作用排除**: `.psm1` ファイルが `Import-Module` でロードされる際に、標準出力に何かを書き出す処理（`Write-Host`など）は行わない。デバッグ情報は`Write-Verbose`を使用する。
  - 内容: `.psm1` がロードされる際に `Write-Host` などで標準出力に書き出さない。これはPester実行時などに予期せぬパースエラーを引き起こす原因となった。デバッグ情報は `Write-Verbose` を使用する。

### 3.6. 再帰関数の使用時の注意点

- **終了条件**: 再帰関数には、必ず明確な終了条件（ベースケース）を設ける。
- **最大再帰深度**: PowerShellのデフォルトの最大再帰呼び出し深度に注意し、非常に深い再帰が予想される場合は、ループ処理への置き換えを検討するか、再帰深度カウンターを設けて意図しない無限ループを防止する。
  - 内容: 必ず終了条件を設け、意図しない無限ループを防ぐために再帰深度カウンターなどの自衛策を設ける (例: `Add-RowToExcelRecursiveDetailed` の `$recursionCount`)。

## 4. エラーハンドリングとロギング

### 4.1. `try-catch-finally` ブロックによる保護

- **対象**: ファイルI/O（`Get-Content`、`Set-Content`、`Test-Path` の後の実処理など）、COMオブジェクト操作、API呼び出し、外部コマンド実行、複雑なデータ変換や計算など、失敗する可能性のあるすべてのクリティカルな処理。
- **`catch` ブロック**: エラーを捕捉し、適切なログ出力、ユーザーへの通知、リソース解放、または安全な終了処理を行う。必要に応じてエラーを再スロー（`throw $_`）する。
- **`finally` ブロック**: 確保したリソース（ファイルハンドル、COMオブジェクト、ネットワーク接続など）を確実に解放する処理を記述する。
  - 内容: エラーが発生しうる全てのクリティカルな処理（特にCOM操作、ファイルI/O）を囲む。

### 4.2. 具体的なエラーメッセージの出力（`Write-Error`）

- **情報量**: エラーが発生した関数名、処理内容、関連する変数やパラメータ、元の例外メッセージ（`$_.Exception.Message`）、可能であればスタックトレース（`$_.ScriptStackTrace`）や発生行（`$_.InvocationInfo.ScriptLineNumber`）を含め、原因特定と対処に必要な情報を十分に提供する。
- **ユーザーフレンドリー**: 技術的すぎない、ユーザーが理解できる言葉でエラーの概要と推奨されるアクションを示すことも検討。
- **`-ForegroundColor`**: `Write-Error` はこのパラメータをサポートしないため使用しない。
  - 内容: 発生箇所、原因、`$_.Exception.Message` を含め、問題解決に繋がる情報を記述する。**`Write-Error` は `-ForegroundColor` パラメータをサポートしない点に注意。**

### 4.3. 警告メッセージの適切な使用（`Write-Warning`）

- **用途**: 処理は続行できるものの、潜在的な問題がある場合や、ユーザーに注意を促したい場合に使用する（例: ファイルが見つからない場合デフォルト値で続行、一部データが不正だがスキップして処理など）。
- **`-ForegroundColor`**: `Write-Warning` はこのパラメータをサポートしない。
  - 内容: 処理は続行可能だが注意が必要な場合に使用。

### 4.4. 詳細ログの戦略的な使用（`Write-Verbose`、`Write-Debug`）

- **`Write-Verbose`**: スクリプトの主要な処理ステップの開始・終了、重要な変数の状態変化、条件分岐の結果など、スクリプトの動作を追跡するのに役立つ情報を出力する。ユーザーが `-Verbose` スイッチを付けた場合に表示される。
- **`Write-Debug`**: より詳細な内部状態、ループ内の変数、複雑な計算の途中結果など、開発者向けのデバッグ情報を出力する。ユーザーが `-Debug` スイッチを付けた場合に表示され、ブレークポイントの設定も可能。
- **`-ForegroundColor`**: `Write-Host` と `Write-Debug` では使用可能だが、`Write-Verbose` では使用できない。
  - 内容: 処理のステップ、変数の状態を追跡するために積極的に使用。`-ForegroundColor` は `Write-Host` と `Write-Debug` で適切に使用する。
  - **特に注意**: 今回のデバッグでは、関数の入口/出口、主要な条件分岐、ループ内、COMオブジェクト操作の前後などに詳細なログを仕込むことで、問題箇所を特定できた。この手法を標準化する。

### 4.5. スクリプト終了コード（`exit`）

- **正常終了**: 明示的な `exit 0` は通常不要。スクリプトが最後まで実行されれば正常終了とみなされる。
- **異常終了**: `catch` ブロックや入力検証失敗時など、処理を継続できない場合は `exit <非ゼロの整数>`（例: `exit 1`）を使用して、呼び出し元に異常終了を伝える。`Write-Error` の後で `exit` するのが一般的。
  - 内容: 致命的なエラーが発生し、処理継続が不可能な場合は `exit 1` で終了する。

## 5. コードスタイルとフォーマット

### 5.1. インデントスタイル

- **規則**: プロジェクト全体で統一されたインデントスタイルを使用する。**スペース4つ**を推奨。タブ文字の使用は避けるか、`エディタ`設定でスペースに自動変換する。

### 5.2. 波括弧の位置

- **選択**: K&Rスタイル（`if (...）{`) またはAllmanスタイル（`if (...）\n{`) など、プロジェクトでスタイルを統一する。PowerShellコミュニティではK&Rスタイルが比較的多い。

### 5.3. 行の長さ

- **目安**: 1行あたり80～120文字程度を目安とし、可読性を損なわない範囲で改行する。PowerShellのバッククォート（`` ` ``）による行継続は可読性を下げる場合があるので、パイプライン、パラメータスプラッティング、ハッシュテーブルの複数行記述などで自然に改行することを推奨。

### 5.4. コメント

- **5.4.1. ヘッダコメント**: スクリプトファイル（`.ps1`、`.psm1`）および主要な関数の先頭には、目的、パラメータ、戻り値、使用例などを記述したコメントブロックを設ける（`<# .SYNOPSIS ... #>` 形式を推奨）。
- **5.4.2. 説明**: 複雑なロジック、アルゴリズムの選択理由、一時的なワークアラウンドなど、「なぜ」そのコードが必要なのかを説明するコメントを記述する。
- **5.4.3. アノテーション**: `TODO:`、`FIXME:`、`NOTE:` などの標準的なアノテーションを使用して、将来の作業や注意点を明示する。

## 6. 外部リソース操作

### 6.1. ファイルパス

- **6.1.1. 相対パス**: スクリプト自身の場所を基準とする場合は `$PSScriptRoot` を使用する。
- **6.1.2. パス結合**: `Join-Path` コマンドレットを使用してパス文字列を安全に結合する。文字列の直接連結（`"$path\$file"`）は避ける。
- **6.1.3. 事前確認**: `Test-Path` でファイルやディレクトリの存在、種類（`-PathType Leaf`、`-PathType Container`）を確認してからアクセスする。
  - 内容: `$PSScriptRoot` と `Join-Path` を基本とし、`Test-Path` で存在確認。

### 6.2. ファイルエンコーディング

- **規則**: `Get-Content`、`Set-Content`、`Out-File`、`Add-Content` などのファイル操作コマンドレットでは、`-Encoding` パラメータを明示的に指定する（例: `-Encoding UTF8`、`-Encoding UTF8NoBOM`、`-Encoding Default`）。
- **理由**: 環境によるデフォルトエンコーディングの違いによる文字化けやデータの破損を防ぐ。とくに日本語環境ではUTF-8（BOMなし推奨）が無難。
  - 内容: `-Encoding UTF8` (または `UTF8NoBOM`) を明示的に指定。

### 6.3. COMオブジェクトのライフサイクル管理

- **6.3.1. `finally` での解放**: `New-Object -ComObject` で作成したCOMオブジェクトは、必ず `try-catch-finally` の `finally` ブロックで解放処理を行う。
- **6.3.2. `ReleaseComObject`**: `[System.Runtime.InteropServices.Marshal]::ReleaseComObject（$comObject）` を呼び出して参照カウントを確実に減らす。
- **6.3.3. `$null` 代入**: `ReleaseComObject` の後、該当の変数に `$null` を代入する（`$comObject = $null`）。
- **6.3.4. `GC.Collect（）`**: 通常は不要。COMオブジェクトが多数あり、メモリリークが疑われる場合の最終手段として、`finally` ブロックの最後に限定的に使用を検討。使用する場合は `[System.GC]::WaitForPendingFinalizers（）` もセットで呼び出す。
  - 内容: `try-catch-finally` での厳密な解放処理を徹底。`$excel, $workbook, $worksheet` 等の変数は関数冒頭で `$null` 初期化し、`finally` で `IsComObject` 確認後 `ReleaseComObject` し `$null` 代入。
  - **特に注意**: 解放漏れはファイルロックやプロセス残りの原因となる。

### 6.4. Excel COM操作

- **6.4.1. 初期設定**: 大量の操作前には `$excel.ScreenUpdating = $false`、`$excel.DisplayAlerts = $false`、`$excel.EnableEvents = $false`（必要に応じて）を設定し、処理後に元に戻すか `$excel.Quit（）` する。
- **6.4.2. 値の操作**: セルの値の読み書きには `.Value2` プロパティを基本とする。日付や数値は適切な .NET型で渡し、Excel側で解釈させる。表示形式は `.NumberFormat` で制御。
- **6.4.3. オブジェクトの取得**: `Workbooks.Open（）`、`Worksheets.Item（）`、`Cells.Item（）` などでオブジェクトを取得する際は、戻り値が `$null` でないか確認する。
  - 内容: `$excel.Visible = $false`, `.DisplayAlerts = $false` を基本とする。値の代入は `.Value2` を推奨。
  - **特に注意**: OneDrive同期フォルダ内のExcelファイルをCOM経由で `SaveAs` する際に「アクセスできません」エラーが発生した。これはExcelがオンラインパスを内部的に参照することが原因の可能性。**対策として、テストや実行はローカルの非同期フォルダ (`C:\Temp` など) で行うことを推奨する。**

## 7. テスト

### 7.1. 手動テストケースの作成基準

- **網羅性**: 正常系（主要機能、代表的な入力）、準正常系（許容される範囲の不正入力、オプションパラメータの省略）、異常系（必須パラメータ不足、ファイル不在、アクセス権なし、予期せぬデータ型）、境界値（数値の0、最小/最大、日付の境界など）をカバーする。
- **再現性**: 誰でも同じ手順で実行し、同じ結果が得られるように記述する。
  - 内容: 正常系、準正常系（オプションパラメータの有無など）、異常系（必須ファイル不在、不正フォーマットなど）、境界値を網羅する。

### 7.2. テスト手順書の必須項目

- テストID、テスト対象スクリプト/関数、テスト目的、前提条件、`入力データ/パラメータ`、実行手順、期待される結果（出力ファイルの内容、コンソールメッセージ、エラーの有無など）、確認方法、実施日、実施者、結果（OK/NG）、備考。

### 7.3. テストデータの管理

- テストケースごとに独立した入力データを用意し、バージョン管理に含める。
- `samples` ディレクトリ下にテストシナリオ別のサブディレクトリを作成して管理。
- 出力ファイルと比較するための期待結果ファイルも用意すると良い。
  - 内容: `samples` ディレクトリ下にテストケースごとの入力データを用意し、バージョン管理する。

### 7.4.（将来用）Pesterテスト

- ファイル名は `*.Tests.ps1` とする。
- `Describe`、`Context`、`It` を使用してテストを構造化する。
- `Should` と適切なアサーションオペレータ（`-Be`、`-HaveCount`、`-Contain`、`-Throw` など）を使用する。
- `BeforeAll`、`AfterAll`、`BeforeEach`、`AfterEach` でテストのセットアップとティアダウンを行う。
- モック（`Mock` コマンド）を活用して外部依存性を排除する。
  - 内容: **現状、PowerShell 7.5.1 と Pester 5.7.1 の組み合わせで、ファイルベースのテスト実行時に `Should` 構文の `ParseException` が発生する未解決の問題があるため、Pesterの利用は一時保留とする。** 将来的にPesterのバージョンアップや問題解決後に再検討する。それまでは手動テストと簡易的な自動チェックで品質を担保する。

## 8. バージョン管理

### 8.1. Gitの使用

- **必須**: すべてのスクリプト、モジュール、ドキュメント、テストデータはGitでバージョン管理する。
- **リポジトリ**: プロジェクト単位でリポジトリを作成。

### 8.2. コミットメッセージ

- **規約**: プロジェクトで統一されたコミットメッセージ規約に従う（例: Conventional Commits）。
- **内容**: 何をなぜ変更したのかを簡潔かつ明確に記述する。

### 8.3. ブランチ戦略

- **推奨**: `main`（または `master`）ブランチは安定版とし、機能追加やバグ修正は `feature/` や `fix/` などのプレフィックスを付けたトピックブランチで行い、レビュー後にマージする（例: Git Flow、GitHub Flow）。

## 9. ドキュメント

### 9.1. スクリプトヘッダコメント

- **形式**: PowerShellの標準的なコメントベースのヘルプ形式（`<# .SYNOPSIS ... #>`）を使用する。
- **必須項目**: `.SYNOPSIS`（概要）、`.DESCRIPTION`（詳細説明）、`.PARAMETER <ParamName>` （各パラメータの説明）、`.EXAMPLE`（使用例）、`.NOTES`（バージョン、作者、その他注記）。

### 9.2. 設計と実装の同期

- **重要**: 要件定義書、設計書などのドキュメントと、実際のスクリプト実装は常に同期が取れている状態を維持する。
- **変更時**: コードを修正した場合は、関連するドキュメントも必ず更新する。

### 9.3. ドキュメント更新手順

- プロジェクト内でドキュメントの更新ルール（誰が、いつ、どのように更新するか）を定めておく。

## 10. その他・固有の教訓

### 10.1. 複数AI支援ツール使用時

- **検証**: AIの提案は鵜呑みにせず、必ず自身で内容を理解し、テストして検証する。
- **情報提供**: AIに質問や依頼をする際は、正確かつ十分なコンテキスト（エラーメッセージ全文、関連コード、仕様、目的など）を提供する。
- **限界認識**: AIは万能ではなく、とくに複雑なロジックや環境固有の問題の解決には限界があることを理解する。

### 10.2. PowerShellバージョン互換性

- **意識**: スクリプトが特定のPowerShellバージョンに依存する機能を使用している場合は、その旨をコメントやドキュメントに明記し、可能であれば `#Requires -Version <バージョン>` を記述する。
- **フォールバック**: `ConvertFrom-Yaml` のように、利用できない場合の代替処理を実装することも検討する。

### 10.3. 特殊なファイルパス環境

- **注意**: `OneDrive同期フォルダ`、ネットワークドライブ、日本語や特殊文字を含むパスなどでは、ファイルI/Oや外部コマンド実行時に予期せぬ問題が発生する可能性があるため、動作確認を慎重に行う。可能な限りシンプルなASCII文字パスでのテストも行う。
  - 内容: OneDrive同期フォルダなどでのCOM操作は予期せぬ挙動を示す可能性があるため、ローカル非同期フォルダでの動作確認を推奨。
  - **10.4. パラメータバインディングエラーのデバッグ**
    - 内容: 「`A parameter cannot be found that matches parameter name 'X'`」や「`Cannot bind argument to parameter 'Y' because it is an empty string/array`」といったエラーは、関数定義 (`param` ブロック) と呼び出し側のパラメータ名・型・必須属性・デフォルト値の不整合が原因である。両者を徹底的に比較検証する。
  - **10.5. `Write-Error` と `-ForegroundColor`**
    - 内容: `Write-Error` コマンドレットは `-ForegroundColor` パラメータをサポートしない。指定すると `ParameterBindingException` が発生する。
  - **10.6. 文字列展開とコマンド誤認識**
    - 内容: `Write-Host "Error: $variable"` のような場合で、`$variable` の内容が `-` で始まるなどコマンドレットのパラメータのように見える場合、PowerShellが誤解釈してエラーになることがある。表示する際は `Write-Host "Error: '$($variable)'"` のようにシングルクォートで囲むなど注意する。
